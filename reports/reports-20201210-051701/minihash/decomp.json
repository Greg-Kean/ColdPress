{"minihash.exe": {"binwalk": {"0": {"magic": "PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows", "size": 17920, "sha1": "d1c50a1da68a15ea0998b3644bb65d26398bd208"}}, "filetype": "PE32+ executable (console) x86-64 (stripped to external PDB), for MS Windows", "hashes": {"md5": "fcec376ec3d1a7aacf1ab109b4336213", "sha1": "d1c50a1da68a15ea0998b3644bb65d26398bd208", "sha256": "b8bbf87474aa41bc90f0d38683cf6907b15f711424f5bdae2a9dfdbfbd08dcec", "ssdeep": "384:AOCSjrwK5GCz282Pi+6TRiNNNFd57NhKV:AZgwA2yliNNNF7", "pehash": "cc601275353e40c78379d8c5f7e82ac223fc6c98", "imphash": "0d98c4f22aef1264d564980d8a5c51c7", "machoke": "1:c,c,2;1:2,3;2:3;3:4,6;4:5;5:6;6:;1:41;2:3;3:37;4:5;5:3,6;6:38;7:43;8:9;9:39;10:40;11:12,13;12:13;13:c,c,c,c,c,14,19;14:15;15:16,25;16:17,21;17:18;18:19;19:15,20;20:21;21:22,25;22:23;23:24,25;24:23,25;25:26;26:27,29;27:36;28:29;29:c,30,33;30:31;31:c,c,c,31,32;32:33;33:c,c,44;34:42;35:36;36:37;37:7;38:c,10;39:c,11;40:41;41:42;42:c,43;43:c,44;44:c,c,c,45;1:;1:;1:;1:;1:;1:;1:2,3;2:3;3:c,c,2,4;4:25;5:31;6:7;7:31;8:36;9:10,13;10:11;11:c,12;12:13,19;13:30;14:28;15:11,16;16:35;17:c,13,18;18:19;19:2;20:21;21:22,23;22:23;23:21,24;24:25;25:31;26:7;27:28;28:35;29:c,30;30:c,31;31:2;32:33;33:c,33,34;34:35;35:c,36;36:c,37,38;37:38;38:;1:c,2,5;2:3,5;3:c,4,6;4:5;5:6;6:7;7:8,11;8:c,7,9;9:4;10:11;11:12;12:;1:;1:;1:;1:;1:;1:;1:c,2;2:3,7;3:4,6;4:5;5:5,6;6:7;7:8;8:8,9;9:10;10:11,12;11:12;12:;1:;1:c,c,c,c,c,c,c,2;2:3;3:c,c,4,5;4:5;5:6;6:3;7:8;8:2;9:c,c,c,c,c,10;10:c,11;11:10,12;12:;1:;1:;1:;1:;1:;1:c,2;2:3;3:2,4;4:;1:;1:;1:;1:;1:;1:;1:18;2:3,7;3:4,11;4:5,10;5:6;6:7;7:6,8;8:6,9;9:c,10;10:11;11:12,13;12:c,13;13:6,14;14:15,17;15:16;16:c,16,17;17:18;18:c,19;1:c,2;1:;1:;1:;1:2,9;2:c,3,9;3:4,8;4:5;5:6,7;6:7,9;7:5,8;8:9;9:;1:2,3;2:c,3;3:;1:2,3;2:3;3:;1:c,c,c,c,c,2;1:2,4;2:c,3,4;3:4;4:;1:2,3;2:2,3;3:;1:22;2:3;3:4,5;4:11;5:3,6;6:c,25;7:c,26;8:9,10;9:20;10:11;11:12,16;12:23;13:14,15;14:24;15:16;16:15,17;17:18;18:18,19;19:20;20:10;21:c,22;22:23;23:24;24:25;25:c,26;26:c,27;1:;1:c,2,9;2:3,8;3:c,4,8;4:5,9;5:6;6:7,9;7:c,6,8;8:9;9:;1:2,10;2:c,3,10;3:4,9;4:5;5:6,8;6:7,10;7:8;8:5,9;9:10;10:;1:;1:;1:2,7;2:3;3:4,6;4:5,6;5:6;6:3,7;7:;1:;"}, "decompile": "\n/* WARNING: Removing unreachable block (ram,0x004011d8) */\n/* WARNING: Removing unreachable block (ram,0x00401400) */\n/* WARNING: Removing unreachable block (ram,0x004011e1) */\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nulonglong FUN_00401180(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                      undefined8 param_5,undefined *param_6)\n\n{\n  int iVar1;\n  char *pcVar2;\n  char cVar3;\n  int iVar4;\n  undefined *puVar5;\n  undefined *puVar6;\n  undefined *puVar7;\n  longlong lVar8;\n  LPTOP_LEVEL_EXCEPTION_FILTER pPVar9;\n  char **ppcVar10;\n  char *pcVar11;\n  undefined8 *puVar12;\n  size_t sVar13;\n  void *_Dst;\n  undefined8 *puVar14;\n  undefined8 uVar15;\n  LPSTARTUPINFOA p_Var16;\n  LPSTARTUPINFOA lpStartupInfo;\n  undefined *puVar17;\n  undefined *puVar18;\n  ulonglong uVar19;\n  LPSTARTUPINFOA p_Var20;\n  longlong in_GS_OFFSET;\n  bool bVar21;\n  undefined8 extraout_XMM0_Qa;\n  undefined8 extraout_XMM0_Qa_00;\n  undefined8 local_a8 [7];\n  byte local_6c;\n  ushort local_68;\n  \n  puVar7 = PTR_DAT_00405530;\n  p_Var16 = (LPSTARTUPINFOA)0xd;\n  lpStartupInfo = (LPSTARTUPINFOA)local_a8;\n  p_Var20 = lpStartupInfo;\n  while (p_Var16 != (LPSTARTUPINFOA)0x0) {\n    p_Var16 = (LPSTARTUPINFOA)((longlong)&p_Var16[-1].hStdError + 7);\n    *(undefined8 *)p_Var20 = 0;\n    p_Var20 = (LPSTARTUPINFOA)&p_Var20->lpReserved;\n  }\n  uVar19 = (ulonglong)*(uint *)PTR_DAT_00405530;\n  p_Var20 = lpStartupInfo;\n  if (*(uint *)PTR_DAT_00405530 != 0) {\n    GetStartupInfoA(lpStartupInfo);\n    p_Var16 = lpStartupInfo;\n    param_1 = extraout_XMM0_Qa_00;\n  }\n  puVar5 = PTR_DAT_00405480;\n  LOCK();\n  *(ulonglong *)PTR_DAT_00405480 =\n       *(ulonglong *)PTR_DAT_00405480 ^\n       (ulonglong)(*(longlong *)PTR_DAT_00405480 == 0) *\n       (*(ulonglong *)PTR_DAT_00405480 ^ *(ulonglong *)(*(longlong *)(in_GS_OFFSET + 0x30) + 8));\n  puVar17 = PTR_DAT_004054d0;\n  lpStartupInfo = (LPSTARTUPINFOA)PTR_DAT_004054c0;\n  puVar6 = PTR_DAT_00405490;\n  if (*(int *)PTR_DAT_00405490 == 1) {\n    lpStartupInfo = (LPSTARTUPINFOA)0x1f;\n    _amsg_exit(0x1f);\n    iVar4 = *(int *)puVar6;\n    puVar17 = param_6;\n    param_1 = extraout_XMM0_Qa;\n    p_Var16 = (LPSTARTUPINFOA)PTR_DAT_004054a0;\n    puVar18 = PTR_DAT_004054b0;\n  }\n  else {\n    if (*(int *)PTR_DAT_00405490 == 0) {\n      *(undefined4 *)PTR_DAT_00405490 = 1;\n      param_1 = _initterm();\n    }\n    else {\n      DAT_00408008 = 1;\n      lpStartupInfo = p_Var16;\n      puVar17 = param_6;\n    }\n    iVar4 = *(int *)puVar6;\n    p_Var16 = (LPSTARTUPINFOA)PTR_DAT_004054a0;\n    puVar18 = PTR_DAT_004054b0;\n  }\n  PTR_DAT_004054a0 = (undefined *)p_Var16;\n  PTR_DAT_004054b0 = puVar18;\n  if (iVar4 == 1) {\n    param_1 = _initterm();\n    *(undefined4 *)puVar6 = 2;\n    lpStartupInfo = p_Var16;\n    puVar17 = puVar18;\n  }\n  *(undefined8 *)puVar5 = 0;\n  if (*(code **)PTR_PTR_tls_callback_0_00405420 != (code *)0x0) {\n    p_Var20 = (LPSTARTUPINFOA)0x0;\n    puVar17 = (undefined *)0x2;\n    lpStartupInfo = (LPSTARTUPINFOA)0x0;\n    param_1 = (**(code **)PTR_PTR_tls_callback_0_00405420)();\n  }\n  FUN_00401ff0(param_1,param_2,param_3,param_4,lpStartupInfo,puVar17,(ulonglong)p_Var20,uVar19);\n  pPVar9 = SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)&LAB_00402600);\n  *(LPTOP_LEVEL_EXCEPTION_FILTER *)PTR_DAT_00405470 = pPVar9;\n  FUN_00402500();\n  FUN_00402f30(&LAB_00401000);\n  FUN_00401d60();\n  _DAT_00408968 = PTR_IMAGE_DOS_HEADER_00405430;\n  ppcVar10 = (char **)FUN_00402f40();\n  iVar4 = DAT_00408028;\n  bVar21 = false;\n  pcVar11 = *ppcVar10;\n  if (pcVar11 != (char *)0x0) {\n    do {\n      cVar3 = *pcVar11;\n      if (cVar3 < '!') {\n        _DAT_00408960 = pcVar11;\n        if (cVar3 == '\\0') break;\n        if (!bVar21) goto LAB_004012d0;\n        bVar21 = true;\n      }\n      else {\n        if (cVar3 == '\\\"') {\n          bVar21 = (bool)(bVar21 ^ 1);\n        }\n      }\n      pcVar11 = pcVar11 + 1;\n    } while( true );\n  }\n  goto LAB_004012f0;\nLAB_004012d0:\n  if (cVar3 != '\\0') {\n    do {\n      pcVar2 = pcVar11 + 1;\n      pcVar11 = pcVar11 + 1;\n      _DAT_00408960 = pcVar11;\n      if (*pcVar2 == '\\0') break;\n    } while (*pcVar2 < '!');\n  }\nLAB_004012f0:\n  if ((*(int *)puVar7 != 0) && (_DAT_00404000 = 10, (local_6c & 1) != 0)) {\n    _DAT_00404000 = (uint)local_68;\n  }\n  iVar1 = DAT_00408028 + 1;\n  puVar12 = (undefined8 *)malloc((longlong)iVar1 * 8);\n  lVar8 = (longlong)DAT_00408020;\n  puVar14 = puVar12;\n  if (0 < iVar4) {\n    uVar19 = 0;\n    do {\n      sVar13 = strlen(*(char **)(lVar8 + uVar19 * 8));\n      _Dst = malloc(sVar13 + 1);\n      *(void **)(puVar12 + uVar19) = _Dst;\n      memcpy(_Dst,*(void **)(lVar8 + uVar19 * 8),sVar13 + 1);\n      bVar21 = (ulonglong)(iVar4 - 1) != uVar19;\n      uVar19 = uVar19 + 1;\n    } while (bVar21);\n    puVar14 = puVar12 + (longlong)iVar1 + -1;\n  }\n  *puVar14 = 0;\n  DAT_00408020 = puVar12;\n  FUN_00401970();\n  **(undefined8 **)PTR_PTR___initenv_00405440 = DAT_00408018;\n  uVar15 = FUN_00401609();\n  DAT_00408010 = (uint)uVar15;\n  if (DAT_0040800c == 0) {\n                    /* WARNING: Subroutine does not return */\n    exit(DAT_00408010);\n  }\n  if (DAT_00408008 == 0) {\n    _cexit();\n    return (ulonglong)DAT_00408010;\n  }\n  return uVar15;\n}\n\n\nvoid entry(void)\n\n{\n  *(undefined4 *)PTR_DAT_00405530 = 0;\n  FUN_004019b0();\n  FUN_00401180();\n  return;\n}\n\n\nlonglong FUN_00401560(longlong param_1,ulonglong param_2)\n\n{\n  ulonglong uVar1;\n  longlong lVar2;\n  longlong local_18;\n  ulonglong local_10;\n  \n  malloc(8);\n  local_18 = 1;\n  local_10 = 0;\n  while (local_10 < param_2) {\n    uVar1 = local_18 + (ulonglong)(uint)((int)*(char *)(local_10 + param_1) * -0x21524111);\n    lVar2 = SUB168(ZEXT816(uVar1) * ZEXT816(0x6fe82d2af7eed7cd) >> 0x40,0);\n    local_18 = uVar1 + ((uVar1 - lVar2 >> 1) + lVar2 >> 0x33) * -0xb221caf2e9c39;\n    local_10 = local_10 + 1;\n  }\n  return local_18;\n}\n\n\nundefined8 FUN_00401609(void)\n\n{\n  longlong lVar1;\n  size_t sVar2;\n  undefined8 *puVar3;\n  undefined8 *puVar4;\n  undefined8 local_3b8 [100];\n  longlong local_98 [4];\n  longlong local_78;\n  undefined *local_70;\n  FILE *local_68;\n  char *local_60;\n  char *local_58;\n  char *local_50;\n  undefined8 local_48;\n  undefined8 local_40;\n  undefined8 local_38;\n  undefined8 local_30;\n  uint local_24;\n  int local_20;\n  int local_1c;\n  \n  FUN_00401970();\n  puts(\"benign malware for testing coldpress\\n\");\n  lVar1 = FUN_00401560((longlong)\"hello world\",0xb);\n  printf(\"minihash of \\'hello world\\': %llu\\n\",lVar1);\n  FUN_00401560((longlong)\"hello world!\",0xc);\n  printf(\"minihash of \\'hello world!\\': %llu\\n\");\n  local_30 = 0x1102a66d;\n  local_38 = 0x4d4766c;\n  local_40 = 0xfa426de4;\n  local_48 = 0x964baab1;\n  local_98[0] = 0x1102a66d;\n  local_98[1] = 0x4d4766c;\n  local_98[2] = 0xfa426de4;\n  local_98[3] = 0x964baab1;\n  local_50 = (char *)malloc(10);\n  local_1c = 0;\n  while (local_1c < 4) {\n    local_20 = 0x41;\n    while (local_20 < 0x5a) {\n      local_70 = (undefined *)malloc(4);\n      *local_70 = (char)local_20;\n      local_70[1] = 0;\n      local_78 = FUN_00401560((longlong)local_70,1);\n      if (local_78 == local_98[local_1c]) {\n        local_50[local_1c] = (char)local_20;\n      }\n      local_20 = local_20 + 1;\n    }\n    local_1c = local_1c + 1;\n  }\n  local_50[local_1c] = '\\0';\n  local_58 = getenv(local_50);\n  sVar2 = strlen(local_58);\n  local_60 = (char *)malloc(sVar2 + 0x32);\n  sprintf(local_60,\"%s\\\\%s.%s\",local_58,local_50,local_50);\n  local_68 = fopen(local_60,\"w\");\n  lVar1 = 99;\n  puVar3 = &DAT_00404020;\n  puVar4 = local_3b8;\n  while (lVar1 != 0) {\n    lVar1 = lVar1 + -1;\n    *puVar4 = *puVar3;\n    puVar3 = puVar3 + 1;\n    puVar4 = puVar4 + 1;\n  }\n  local_24 = 0;\n  while (local_24 < 99) {\n    fprintf(local_68,\"%llu,\",local_3b8[(int)local_24]);\n    local_24 = local_24 + 1;\n  }\n  return 0;\n}\n\n\nvoid FUN_004018c0(void)\n\n{\n  code *pcVar1;\n  \n  pcVar1 = *(code **)PTR_DAT_00404340;\n  while (pcVar1 != (code *)0x0) {\n    (*pcVar1)();\n    pcVar1 = *(code **)(PTR_DAT_00404340 + 8);\n    PTR_DAT_00404340 = PTR_DAT_00404340 + 8;\n  }\n  return;\n}\n\n\nulonglong FUN_00401970(void)\n\n{\n  code **ppcVar1;\n  uint uVar2;\n  _onexit_t p_Var3;\n  ulonglong uVar4;\n  code **ppcVar5;\n  \n  if (DAT_00408030 == 0) {\n    DAT_00408030 = 1;\n    uVar2 = (uint)*(undefined8 *)PTR_DAT_004053f0;\n    if (uVar2 == 0xffffffff) {\n      uVar4 = 0;\n      do {\n        uVar2 = (uint)uVar4;\n        uVar4 = (ulonglong)(uVar2 + 1);\n      } while (*(longlong *)(PTR_DAT_004053f0 + uVar4 * 8) != 0);\n    }\n    if (uVar2 != 0) {\n      ppcVar5 = (code **)(PTR_DAT_004053f0 + (ulonglong)uVar2 * 8);\n      ppcVar1 = (code **)(PTR_DAT_004053f0 + ((ulonglong)uVar2 - (ulonglong)(uVar2 - 1)) * 8 + -8);\n      do {\n        (**ppcVar5)();\n        ppcVar5 = ppcVar5 + -1;\n      } while (ppcVar5 != ppcVar1);\n    }\n    p_Var3 = _onexit(FUN_004018c0);\n    return (ulonglong)-(uint)(p_Var3 == (_onexit_t)0x0);\n  }\n  return (ulonglong)DAT_00408030;\n}\n\n\nundefined8 FUN_004019a0(void)\n\n{\n  return 0;\n}\n\n\n/* WARNING: Globals starting with '_' overlap smaller symbols at the same address */\n\nvoid FUN_004019b0(void)\n\n{\n  _FILETIME _Var1;\n  DWORD DVar2;\n  DWORD DVar3;\n  DWORD DVar4;\n  _FILETIME local_38;\n  ulonglong local_30;\n  \n  local_38 = (_FILETIME)0x0;\n  if (DAT_004043d0 != 0x2b992ddfa232) {\n    _DAT_004043e0 = ~DAT_004043d0;\n    return;\n  }\n  GetSystemTimeAsFileTime((LPFILETIME)&local_38);\n  _Var1 = local_38;\n  DVar2 = GetCurrentProcessId();\n  DVar3 = GetCurrentThreadId();\n  DVar4 = GetTickCount();\n  QueryPerformanceCounter(&local_30);\n  DAT_004043d0 = ((ulonglong)DVar4 ^\n                 (ulonglong)DVar3 ^ (ulonglong)DVar2 ^ (ulonglong)_Var1 ^ local_30) & 0xffffffffffff\n  ;\n  if (DAT_004043d0 == 0x2b992ddfa232) {\n    _DAT_004043e0 = 0xffffd466d2205dcc;\n    DAT_004043d0 = 0x2b992ddfa233;\n  }\n  else {\n    _DAT_004043e0 = ~DAT_004043d0;\n  }\n  return;\n}\n\n\nundefined8 tls_callback_1(undefined8 param_1,uint param_2)\n\n{\n  if ((param_2 != 3) && (param_2 != 0)) {\n    return 1;\n  }\n  FUN_00402930(param_1,param_2);\n  return 1;\n}\n\n\n/* WARNING: Removing unreachable block (ram,0x00401c03) */\n/* WARNING: Removing unreachable block (ram,0x00401c08) */\n/* WARNING: Removing unreachable block (ram,0x00401c10) */\n/* WARNING: Removing unreachable block (ram,0x00401c12) */\n/* WARNING: Removing unreachable block (ram,0x00401c1b) */\n\nundefined8 tls_callback_0(undefined8 param_1,int param_2)\n\n{\n  if (*(int *)PTR_DAT_004053d0 != 2) {\n    *(undefined4 *)PTR_DAT_004053d0 = 2;\n  }\n  if ((param_2 != 2) && (param_2 == 1)) {\n    FUN_00402930(param_1,1);\n    return 1;\n  }\n  return 1;\n}\n\n\nvoid FUN_00401d60(void)\n\n{\n  return;\n}\n\n\nvoid FUN_00401d70(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 char **param_5,undefined8 param_6,undefined8 param_7,undefined8 param_8)\n\n{\n  int *piVar1;\n  byte bVar2;\n  ushort uVar3;\n  undefined8 lpAddress;\n  undefined *puVar4;\n  undefined *puVar5;\n  uint uVar6;\n  BOOL BVar7;\n  DWORD DVar8;\n  FILE *_File;\n  FILE **ppFVar9;\n  char *pcVar10;\n  undefined4 *puVar11;\n  IMAGE_DOS_HEADER *pIVar12;\n  SIZE_T SVar13;\n  longlong lVar14;\n  int iVar15;\n  undefined4 uVar16;\n  ulonglong param_7_00;\n  longlong *plVar17;\n  int flNewProtect;\n  ulonglong param_6_00;\n  uint uVar18;\n  uint *puVar19;\n  longlong lVar20;\n  int *piVar21;\n  undefined8 *param_7_01;\n  undefined8 param_1_00;\n  undefined8 extraout_XMM0_Qa;\n  undefined8 param_1_01;\n  undefined8 extraout_XMM0_Qa_00;\n  undefined8 dwSize;\n  undefined8 local_res10;\n  undefined8 local_res18;\n  undefined8 local_res20;\n  undefined8 auStack408 [5];\n  undefined4 auStack368 [2];\n  ulonglong auStack360 [5];\n  undefined8 uStack320;\n  undefined auStack280 [8];\n  ulonglong auStack272 [2];\n  undefined8 *puStack256;\n  char **ppcStack248;\n  longlong lStack240;\n  FILE *pFStack232;\n  char *pcStack200;\n  _MEMORY_BASIC_INFORMATION _Stack160;\n  undefined8 *puStack112;\n  char **ppcStack80;\n  undefined8 *local_20;\n  \n  local_20 = &local_res10;\n  ppcStack80 = (char **)0x401d9d;\n  local_res10 = param_6;\n  local_res18 = param_7;\n  local_res20 = param_8;\n  _File = FUN_00402f00(2);\n  ppcStack80 = (char **)0x401db7;\n  fwrite(\"Mingw-w64 runtime failure:\\n\",1,0x1b,_File);\n  puStack112 = local_20;\n  ppcStack80 = (char **)0x401dc6;\n  pFStack232 = FUN_00402f00(2);\n  ppcStack80 = (char **)0x401dd4;\n  ppcStack248 = param_5;\n  puStack256 = puStack112;\n  vfprintf(pFStack232,(char *)param_5,(va_list)puStack112);\n  ppcStack80 = (char **)0x401dd9;\n  abort();\n  lStack240 = (longlong)DAT_00408614;\n  param_7_01 = puStack256;\n  ppcStack80 = param_5;\n  if (DAT_00408614 < 1) goto LAB_00401f88;\n  iVar15 = 0;\n  ppFVar9 = (FILE **)((longlong)DAT_00408618 + 0x18);\n  do {\n    if ((*ppFVar9 <= pFStack232) &&\n       (param_7_01 = (undefined8 *)(ulonglong)(uint)ppFVar9[1]->_cnt,\n       pFStack232 < (FILE *)((longlong)&(*ppFVar9)->_ptr + (longlong)param_7_01)))\n    goto LAB_00401eb7;\n    iVar15 = iVar15 + 1;\n    ppFVar9 = ppFVar9 + 5;\n  } while (iVar15 != DAT_00408614);\n  while( true ) {\n    pcStack200 = (char *)0x401e3f;\n    pcVar10 = FUN_00402b40((longlong)pFStack232);\n    if (pcVar10 == (char *)0x0) break;\n    lStack240 = lStack240 * 0x28;\n    puVar11 = (undefined4 *)((longlong)DAT_00408618 + lStack240);\n    *(char **)(puVar11 + 8) = pcVar10;\n    *puVar11 = 0;\n    pcStack200 = (char *)0x401e6c;\n    pIVar12 = FUN_00402c70();\n    uVar18 = *(uint *)(pcVar10 + 0xc);\n    *(char **)((longlong)DAT_00408618 + lStack240 + 0x18) = pIVar12->e_magic + uVar18;\n    pcStack200 = (char *)0x401e8f;\n    SVar13 = VirtualQuery(pIVar12->e_magic + uVar18,(PMEMORY_BASIC_INFORMATION)&_Stack160,0x30);\n    dwSize = extraout_XMM0_Qa;\n    if (SVar13 == 0) goto LAB_00401fd1;\n    if (((_Stack160.Protect - 0x40 & 0xffffffbf) == 0) ||\n       ((_Stack160.Protect - 4 & 0xfffffffb) == 0)) {\nLAB_00401eb0:\n      DAT_00408614 = DAT_00408614 + 1;\nLAB_00401eb7:\n      uVar18 = (uint)puStack256;\n      if (uVar18 < 8) {\n        if (((ulonglong)puStack256 & 4) == 0) {\n          if ((uVar18 != 0) &&\n             (*(undefined *)&pFStack232->_ptr = *(undefined *)ppcStack248,\n             ((ulonglong)puStack256 & 2) != 0)) {\n            *(undefined2 *)\n             ((longlong)&pFStack232[-1]._tmpfname + ((ulonglong)puStack256 & 0xffffffff) + 6) =\n                 *(undefined2 *)((longlong)ppcStack248 + (((ulonglong)puStack256 & 0xffffffff) - 2))\n            ;\n          }\n        }\n        else {\n          *(undefined4 *)&pFStack232->_ptr = *(undefined4 *)ppcStack248;\n          *(undefined4 *)\n           ((longlong)&pFStack232[-1]._tmpfname + ((ulonglong)puStack256 & 0xffffffff) + 4) =\n               *(undefined4 *)((longlong)ppcStack248 + (((ulonglong)puStack256 & 0xffffffff) - 4));\n        }\n      }\n      else {\n        param_7_00 = (ulonglong)&pFStack232->_cnt & 0xfffffffffffffff8;\n        pFStack232->_ptr = *ppcStack248;\n        *(undefined8 *)((longlong)&pFStack232[-1]._tmpfname + ((ulonglong)puStack256 & 0xffffffff))\n             = *(undefined8 *)((longlong)ppcStack248 + (((ulonglong)puStack256 & 0xffffffff) - 8));\n        pFStack232 = (FILE *)((longlong)pFStack232 - param_7_00);\n        uVar18 = uVar18 + (int)pFStack232 & 0xfffffff8;\n        if (7 < uVar18) {\n          uVar6 = 0;\n          do {\n            param_6_00 = (ulonglong)uVar6;\n            uVar6 = uVar6 + 8;\n            *(undefined8 *)(param_7_00 + param_6_00) =\n                 *(undefined8 *)((longlong)ppcStack248 + (param_6_00 - (longlong)pFStack232));\n          } while (uVar6 < uVar18);\n          return;\n        }\n      }\n      return;\n    }\n    param_7_01 = (undefined8 *)0x40;\n    _File = (FILE *)((longlong)DAT_00408618 + lStack240);\n    *(LPVOID *)&_File->_cnt = _Stack160.BaseAddress;\n    _File->_base = _Stack160.RegionSize;\n    pcStack200 = (char *)0x401f68;\n    BVar7 = VirtualProtect(_Stack160.BaseAddress,(SIZE_T)_Stack160.RegionSize,0x40,(PDWORD)_File);\n    if (BVar7 != 0) goto LAB_00401eb0;\n    pcStack200 = (char *)0x401f76;\n    DVar8 = GetLastError();\n    pcStack200 = \"\\x0f\\x1f@\";\n    FUN_00401d70(param_1_01,param_2,param_3,param_4,\n                 (char **)\"  VirtualProtect failed with code 0x%x\",(ulonglong)DVar8,param_7_01,_File\n                );\nLAB_00401f88:\n    lStack240 = 0;\n  }\n  pcStack200 = (char *)0x401fd1;\n  dwSize = FUN_00401d70(param_1_00,param_2,param_3,param_4,\n                        (char **)\"Address %p has no image-section\",pFStack232,param_7_01,_File);\nLAB_00401fd1:\n  param_7_00 = *(ulonglong *)((longlong)DAT_00408618 + lStack240 + 0x18);\n  pcStack200 = (char *)0x401fec;\n  FUN_00401d70(dwSize,param_2,param_3,param_4,\n               (char **)\"  VirtualQuery failed for %d bytes at address %p\",\n               (ulonglong)*(uint *)(pcVar10 + 8),param_7_00,_File);\n  iVar15 = DAT_00408610;\n  if (DAT_00408610 != 0) {\n    return;\n  }\n  DAT_00408610 = 1;\n  uStack320 = 0x402037;\n  pcStack200 = pcVar10;\n  FUN_00402bd0();\n  uStack320 = 0x40204e;\n  lVar14 = FUN_00402df0();\n  puVar5 = PTR_IMAGE_DOS_HEADER_00405430;\n  puVar4 = PTR_DAT_00405400;\n  DAT_00408614 = 0;\n  lVar14 = -lVar14;\n  DAT_00408618 = auStack280 + lVar14;\n  if ((longlong)(PTR_DAT_00405400 + -(longlong)PTR_DAT_00405410) < 8) {\n    DAT_00408614 = 0;\n    return;\n  }\n  flNewProtect = *(int *)PTR_DAT_00405410;\n  piVar21 = (int *)PTR_DAT_00405410;\n  if ((longlong)(PTR_DAT_00405400 + -(longlong)PTR_DAT_00405410) < 0xc) {\nLAB_0040208d:\n    if (flNewProtect == 0) {\n      uVar18 = piVar21[1];\nLAB_00402098:\n      if (uVar18 == 0) {\n        param_6_00 = (ulonglong)(uint)piVar21[2];\n        dwSize = extraout_XMM0_Qa_00;\n        if (piVar21[2] != 1) {\nLAB_004022c8:\n          uVar16 = 0x405300;\n          *(ulonglong *)((longlong)(auStack360 + 5) + lVar14) = 0x4022d4;\n          FUN_00401d70(dwSize,param_2,param_3,param_4,\n                       \"  Unknown pseudo relocation protocol version %d.\\n\",param_6_00,param_7_00,\n                       _File,*(undefined *)((longlong)(auStack360 + 5) + lVar14));\n          if (DAT_00408620 != (code *)0x0) {\n            param_7_00 = *(ulonglong *)((longlong)auStack272 + lVar14);\n            *(undefined4 *)((longlong)auStack368 + lVar14) = uVar16;\n            *(ulonglong *)((longlong)auStack360 + lVar14) = param_6_00;\n            *(undefined8 *)((longlong)auStack360 + lVar14 + 8) = param_3;\n            *(undefined8 *)((longlong)auStack360 + lVar14 + 0x10) = param_4;\n            *(ulonglong *)((longlong)auStack360 + lVar14 + 0x18) = param_7_00;\n            *(undefined8 *)((longlong)auStack408 + lVar14) = 0x40231b;\n            (*DAT_00408620)((undefined4 *)((longlong)auStack368 + lVar14));\n          }\n          return;\n        }\n        puVar19 = (uint *)(piVar21 + 3);\n        if (PTR_DAT_00405400 <= puVar19) {\n          DAT_00408614 = 0;\n          return;\n        }\n        do {\n          while( true ) {\n            bVar2 = *(byte *)(puVar19 + 2);\n            param_7_00 = (ulonglong)bVar2;\n            ppFVar9 = (FILE **)(puVar5 + *puVar19);\n            plVar17 = (longlong *)(puVar5 + puVar19[1]);\n            _File = *ppFVar9;\n            if (bVar2 != 0x20) break;\n            uVar18 = *(uint *)plVar17;\n            param_7_00 = (ulonglong)uVar18 | 0xffffffff00000000;\n            if (-1 < (int)uVar18) {\n              param_7_00 = (ulonglong)uVar18;\n            }\n            auStack272[0] = (param_7_00 - (longlong)ppFVar9) + (longlong)_File;\n            *(ulonglong *)((longlong)(auStack360 + 5) + lVar14) = 0x40225a;\n            dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,plVar17,auStack272,4,_File,\n                                  *(undefined *)((longlong)(auStack360 + 5) + lVar14));\nLAB_00402100:\n            puVar19 = puVar19 + 3;\n            if (puVar4 <= puVar19) goto LAB_00402180;\n          }\n          if (0x20 < bVar2) {\n            if (bVar2 == 0x40) {\n              auStack272[0] = (*plVar17 - (longlong)ppFVar9) + (longlong)_File;\n              *(ulonglong *)((longlong)(auStack360 + 5) + lVar14) = 0x402228;\n              dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,plVar17,auStack272,8,_File,\n                                    *(undefined *)((longlong)(auStack360 + 5) + lVar14));\n              goto LAB_00402100;\n            }\nLAB_004022b1:\n            param_6_00 = (ulonglong)bVar2;\n            auStack272[0] = 0;\n            *(ulonglong *)((longlong)(auStack360 + 5) + lVar14) = 0x4022c8;\n            dwSize = FUN_00401d70(dwSize,param_2,param_3,param_4,\n                                  \"  Unknown pseudo relocation bit size %d.\\n\",param_6_00,param_7_00\n                                  ,_File,*(undefined *)((longlong)(auStack360 + 5) + lVar14));\n            goto LAB_004022c8;\n          }\n          if (bVar2 == 8) {\n            bVar2 = *(byte *)plVar17;\n            param_7_00 = (ulonglong)bVar2;\n            if ((char)bVar2 < '\\0') {\n              param_7_00 = (ulonglong)bVar2 | 0xffffffffffffff00;\n            }\n            auStack272[0] = (param_7_00 - (longlong)ppFVar9) + (longlong)_File;\n            *(ulonglong *)((longlong)(auStack360 + 5) + lVar14) = 0x402100;\n            dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,plVar17,auStack272,1,_File,\n                                  *(undefined *)((longlong)(auStack360 + 5) + lVar14));\n            goto LAB_00402100;\n          }\n          if (bVar2 != 0x10) goto LAB_004022b1;\n          uVar3 = *(ushort *)plVar17;\n          param_7_00 = (ulonglong)uVar3;\n          if ((short)uVar3 < 0) {\n            param_7_00 = (ulonglong)uVar3 | 0xffffffffffff0000;\n          }\n          puVar19 = puVar19 + 3;\n          auStack272[0] = (param_7_00 - (longlong)ppFVar9) + (longlong)_File;\n          *(ulonglong *)((longlong)(auStack360 + 5) + lVar14) = 0x402171;\n          dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,plVar17,auStack272,2,_File,\n                                *(undefined *)((longlong)(auStack360 + 5) + lVar14));\n        } while (puVar19 < puVar4);\n        goto LAB_00402180;\n      }\n    }\n  }\n  else {\n    if (flNewProtect == 0) {\n      uVar18 = *(uint *)(PTR_DAT_00405410 + 4);\n      if ((uVar18 | *(uint *)(PTR_DAT_00405410 + 8)) == 0) {\n        flNewProtect = *(int *)(PTR_DAT_00405410 + 0xc);\n        piVar21 = (int *)(PTR_DAT_00405410 + 0xc);\n        goto LAB_0040208d;\n      }\n      goto LAB_00402098;\n    }\n  }\n  if (PTR_DAT_00405400 <= piVar21) {\n    DAT_00408614 = 0;\n    return;\n  }\n  piVar1 = (int *)((longlong)piVar21 +\n                  ((ulonglong)(PTR_DAT_00405400 + (-1 - (longlong)piVar21)) & 0xfffffffffffffff8) +\n                  8);\n  dwSize = extraout_XMM0_Qa_00;\n  do {\n    uVar18 = piVar21[1];\n    flNewProtect = *piVar21;\n    piVar21 = piVar21 + 2;\n    auStack272[0] =\n         auStack272[0] & 0xffffffff00000000 |\n         (ulonglong)(uint)(flNewProtect + *(int *)(puVar5 + uVar18));\n    *(ulonglong *)((longlong)(auStack360 + 5) + lVar14) = 0x4022a7;\n    dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,puVar5 + uVar18,auStack272,4,_File,\n                          *(undefined *)((longlong)(auStack360 + 5) + lVar14));\n  } while (piVar21 != piVar1);\nLAB_00402180:\n  if (0 < DAT_00408614) {\n    lVar20 = 0;\n    do {\n      piVar21 = (int *)(DAT_00408618 + lVar20);\n      flNewProtect = *piVar21;\n      if (flNewProtect != 0) {\n        dwSize = *(undefined8 *)(piVar21 + 4);\n        lpAddress = *(undefined8 *)(piVar21 + 2);\n        *(ulonglong *)((longlong)(auStack360 + 5) + lVar14) = 0x4021c0;\n        VirtualProtect(lpAddress,dwSize,flNewProtect,auStack272,\n                       *(undefined *)((longlong)(auStack360 + 5) + lVar14));\n      }\n      iVar15 = iVar15 + 1;\n      lVar20 = lVar20 + 0x28;\n    } while (iVar15 < DAT_00408614);\n  }\n  return;\n}\n\n\nvoid FUN_00401de0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 *param_5,undefined8 *param_6,ulonglong param_7,PDWORD param_8)\n\n{\n  int *piVar1;\n  byte bVar2;\n  ushort uVar3;\n  undefined8 lpAddress;\n  undefined *puVar4;\n  undefined *puVar5;\n  uint uVar6;\n  BOOL BVar7;\n  DWORD DVar8;\n  ulonglong *puVar9;\n  char *pcVar10;\n  undefined4 *puVar11;\n  IMAGE_DOS_HEADER *pIVar12;\n  SIZE_T SVar13;\n  longlong lVar14;\n  int iVar15;\n  undefined4 uVar16;\n  longlong *param_5_00;\n  int flNewProtect;\n  ulonglong uVar17;\n  PDWORD *ppDVar18;\n  uint uVar19;\n  uint *puVar20;\n  longlong lVar21;\n  int *piVar22;\n  ulonglong uVar23;\n  undefined8 *puVar24;\n  undefined8 extraout_XMM0_Qa;\n  undefined8 extraout_XMM0_Qa_00;\n  undefined8 extraout_XMM0_Qa_01;\n  undefined8 extraout_XMM0_Qa_02;\n  undefined8 dwSize;\n  undefined8 auStack336 [5];\n  undefined4 auStack296 [2];\n  ulonglong auStack288 [5];\n  undefined8 uStack248;\n  undefined auStack208 [8];\n  ulonglong auStack200 [2];\n  ulonglong uStack184;\n  undefined8 *puStack176;\n  longlong lStack168;\n  undefined8 *puStack160;\n  char *pcStack128;\n  _MEMORY_BASIC_INFORMATION local_58;\n  \n  lStack168 = (longlong)DAT_00408614;\n  uVar23 = param_7;\n  if (DAT_00408614 < 1) goto LAB_00401f88;\n  iVar15 = 0;\n  puVar9 = (ulonglong *)((longlong)DAT_00408618 + 0x18);\n  do {\n    if (((undefined8 *)*puVar9 <= param_5) &&\n       (uVar23 = (ulonglong)*(uint *)(puVar9[1] + 8),\n       param_5 < (undefined8 *)((longlong)(undefined8 *)*puVar9 + uVar23))) goto LAB_00401eb7;\n    iVar15 = iVar15 + 1;\n    puVar9 = puVar9 + 5;\n  } while (iVar15 != DAT_00408614);\n  while( true ) {\n    pcStack128 = (char *)0x401e3f;\n    pcVar10 = FUN_00402b40((longlong)param_5);\n    if (pcVar10 == (char *)0x0) break;\n    lStack168 = lStack168 * 0x28;\n    puVar11 = (undefined4 *)((longlong)DAT_00408618 + lStack168);\n    *(char **)(puVar11 + 8) = pcVar10;\n    *puVar11 = 0;\n    pcStack128 = (char *)0x401e6c;\n    pIVar12 = FUN_00402c70();\n    uVar19 = *(uint *)(pcVar10 + 0xc);\n    *(char **)((longlong)DAT_00408618 + lStack168 + 0x18) = pIVar12->e_magic + uVar19;\n    pcStack128 = (char *)0x401e8f;\n    SVar13 = VirtualQuery(pIVar12->e_magic + uVar19,(PMEMORY_BASIC_INFORMATION)&local_58,0x30);\n    dwSize = extraout_XMM0_Qa_00;\n    if (SVar13 == 0) goto LAB_00401fd1;\n    if (((local_58.Protect - 0x40 & 0xffffffbf) == 0) || ((local_58.Protect - 4 & 0xfffffffb) == 0))\n    {\nLAB_00401eb0:\n      DAT_00408614 = DAT_00408614 + 1;\nLAB_00401eb7:\n      uVar19 = (uint)param_7;\n      if (uVar19 < 8) {\n        if ((param_7 & 4) == 0) {\n          if ((uVar19 != 0) && (*(undefined *)param_5 = *(undefined *)param_6, (param_7 & 2) != 0))\n          {\n            *(undefined2 *)((longlong)param_5 + ((param_7 & 0xffffffff) - 2)) =\n                 *(undefined2 *)((longlong)param_6 + ((param_7 & 0xffffffff) - 2));\n          }\n        }\n        else {\n          *(undefined4 *)param_5 = *(undefined4 *)param_6;\n          *(undefined4 *)((longlong)param_5 + ((param_7 & 0xffffffff) - 4)) =\n               *(undefined4 *)((longlong)param_6 + ((param_7 & 0xffffffff) - 4));\n        }\n      }\n      else {\n        *param_5 = *param_6;\n        *(undefined8 *)((longlong)param_5 + ((param_7 & 0xffffffff) - 8)) =\n             *(undefined8 *)((longlong)param_6 + ((param_7 & 0xffffffff) - 8));\n        puVar24 = (undefined8 *)\n                  ((longlong)param_5 - ((ulonglong)(param_5 + 1) & 0xfffffffffffffff8));\n        uVar19 = uVar19 + (int)puVar24 & 0xfffffff8;\n        if (7 < uVar19) {\n          uVar6 = 0;\n          do {\n            uVar23 = (ulonglong)uVar6;\n            uVar6 = uVar6 + 8;\n            *(undefined8 *)(((ulonglong)(param_5 + 1) & 0xfffffffffffffff8) + uVar23) =\n                 *(undefined8 *)((longlong)param_6 + (uVar23 - (longlong)puVar24));\n          } while (uVar6 < uVar19);\n          return;\n        }\n      }\n      return;\n    }\n    uVar23 = 0x40;\n    param_8 = (PDWORD)((longlong)DAT_00408618 + lStack168);\n    *(LPVOID *)(param_8 + 2) = local_58.BaseAddress;\n    *(SIZE_T *)(param_8 + 4) = local_58.RegionSize;\n    pcStack128 = (char *)0x401f68;\n    BVar7 = VirtualProtect(local_58.BaseAddress,local_58.RegionSize,0x40,param_8);\n    if (BVar7 != 0) goto LAB_00401eb0;\n    pcStack128 = (char *)0x401f76;\n    DVar8 = GetLastError();\n    pcStack128 = \"\\x0f\\x1f@\";\n    FUN_00401d70(extraout_XMM0_Qa_01,param_2,param_3,param_4,\n                 (char **)\"  VirtualProtect failed with code 0x%x\",(ulonglong)DVar8,uVar23,param_8);\nLAB_00401f88:\n    lStack168 = 0;\n  }\n  pcStack128 = (char *)0x401fd1;\n  dwSize = FUN_00401d70(extraout_XMM0_Qa,param_2,param_3,param_4,\n                        (char **)\"Address %p has no image-section\",param_5,uVar23,param_8);\nLAB_00401fd1:\n  uVar23 = *(ulonglong *)((longlong)DAT_00408618 + lStack168 + 0x18);\n  pcStack128 = (char *)0x401fec;\n  FUN_00401d70(dwSize,param_2,param_3,param_4,\n               (char **)\"  VirtualQuery failed for %d bytes at address %p\",\n               (ulonglong)*(uint *)(pcVar10 + 8),uVar23,param_8);\n  iVar15 = DAT_00408610;\n  if (DAT_00408610 != 0) {\n    return;\n  }\n  DAT_00408610 = 1;\n  uStack248 = 0x402037;\n  uStack184 = param_7;\n  puStack176 = param_6;\n  puStack160 = param_5;\n  pcStack128 = pcVar10;\n  FUN_00402bd0();\n  uStack248 = 0x40204e;\n  lVar14 = FUN_00402df0();\n  puVar5 = PTR_IMAGE_DOS_HEADER_00405430;\n  puVar4 = PTR_DAT_00405400;\n  DAT_00408614 = 0;\n  lVar14 = -lVar14;\n  DAT_00408618 = auStack208 + lVar14;\n  if ((longlong)(PTR_DAT_00405400 + -(longlong)PTR_DAT_00405410) < 8) {\n    DAT_00408614 = 0;\n    return;\n  }\n  flNewProtect = *(int *)PTR_DAT_00405410;\n  piVar22 = (int *)PTR_DAT_00405410;\n  if ((longlong)(PTR_DAT_00405400 + -(longlong)PTR_DAT_00405410) < 0xc) {\nLAB_0040208d:\n    if (flNewProtect == 0) {\n      uVar19 = piVar22[1];\nLAB_00402098:\n      if (uVar19 == 0) {\n        uVar17 = (ulonglong)(uint)piVar22[2];\n        dwSize = extraout_XMM0_Qa_02;\n        if (piVar22[2] != 1) {\nLAB_004022c8:\n          uVar16 = 0x405300;\n          *(ulonglong *)((longlong)(auStack288 + 5) + lVar14) = 0x4022d4;\n          FUN_00401d70(dwSize,param_2,param_3,param_4,\n                       \"  Unknown pseudo relocation protocol version %d.\\n\",uVar17,uVar23,param_8,\n                       *(undefined *)((longlong)(auStack288 + 5) + lVar14));\n          if (DAT_00408620 != (code *)0x0) {\n            uVar23 = *(ulonglong *)((longlong)auStack200 + lVar14);\n            *(undefined4 *)((longlong)auStack296 + lVar14) = uVar16;\n            *(ulonglong *)((longlong)auStack288 + lVar14) = uVar17;\n            *(undefined8 *)((longlong)auStack288 + lVar14 + 8) = param_3;\n            *(undefined8 *)((longlong)auStack288 + lVar14 + 0x10) = param_4;\n            *(ulonglong *)((longlong)auStack288 + lVar14 + 0x18) = uVar23;\n            *(undefined8 *)((longlong)auStack336 + lVar14) = 0x40231b;\n            (*DAT_00408620)((undefined4 *)((longlong)auStack296 + lVar14));\n          }\n          return;\n        }\n        puVar20 = (uint *)(piVar22 + 3);\n        if (PTR_DAT_00405400 <= puVar20) {\n          DAT_00408614 = 0;\n          return;\n        }\n        do {\n          while( true ) {\n            bVar2 = *(byte *)(puVar20 + 2);\n            uVar23 = (ulonglong)bVar2;\n            ppDVar18 = (PDWORD *)(puVar5 + *puVar20);\n            param_5_00 = (longlong *)(puVar5 + puVar20[1]);\n            param_8 = *ppDVar18;\n            if (bVar2 != 0x20) break;\n            uVar19 = *(uint *)param_5_00;\n            uVar23 = (ulonglong)uVar19 | 0xffffffff00000000;\n            if (-1 < (int)uVar19) {\n              uVar23 = (ulonglong)uVar19;\n            }\n            auStack200[0] = (uVar23 - (longlong)ppDVar18) + (longlong)param_8;\n            *(ulonglong *)((longlong)(auStack288 + 5) + lVar14) = 0x40225a;\n            dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,param_5_00,auStack200,4,param_8,\n                                  *(undefined *)((longlong)(auStack288 + 5) + lVar14));\nLAB_00402100:\n            puVar20 = puVar20 + 3;\n            if (puVar4 <= puVar20) goto LAB_00402180;\n          }\n          if (0x20 < bVar2) {\n            if (bVar2 == 0x40) {\n              auStack200[0] = (*param_5_00 - (longlong)ppDVar18) + (longlong)param_8;\n              *(ulonglong *)((longlong)(auStack288 + 5) + lVar14) = 0x402228;\n              dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,param_5_00,auStack200,8,param_8,\n                                    *(undefined *)((longlong)(auStack288 + 5) + lVar14));\n              goto LAB_00402100;\n            }\nLAB_004022b1:\n            uVar17 = (ulonglong)bVar2;\n            auStack200[0] = 0;\n            *(ulonglong *)((longlong)(auStack288 + 5) + lVar14) = 0x4022c8;\n            dwSize = FUN_00401d70(dwSize,param_2,param_3,param_4,\n                                  \"  Unknown pseudo relocation bit size %d.\\n\",uVar17,uVar23,param_8\n                                  ,*(undefined *)((longlong)(auStack288 + 5) + lVar14));\n            goto LAB_004022c8;\n          }\n          if (bVar2 == 8) {\n            bVar2 = *(byte *)param_5_00;\n            uVar23 = (ulonglong)bVar2;\n            if ((char)bVar2 < '\\0') {\n              uVar23 = (ulonglong)bVar2 | 0xffffffffffffff00;\n            }\n            auStack200[0] = (uVar23 - (longlong)ppDVar18) + (longlong)param_8;\n            *(ulonglong *)((longlong)(auStack288 + 5) + lVar14) = 0x402100;\n            dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,param_5_00,auStack200,1,param_8,\n                                  *(undefined *)((longlong)(auStack288 + 5) + lVar14));\n            goto LAB_00402100;\n          }\n          if (bVar2 != 0x10) goto LAB_004022b1;\n          uVar3 = *(ushort *)param_5_00;\n          uVar23 = (ulonglong)uVar3;\n          if ((short)uVar3 < 0) {\n            uVar23 = (ulonglong)uVar3 | 0xffffffffffff0000;\n          }\n          puVar20 = puVar20 + 3;\n          auStack200[0] = (uVar23 - (longlong)ppDVar18) + (longlong)param_8;\n          *(ulonglong *)((longlong)(auStack288 + 5) + lVar14) = 0x402171;\n          dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,param_5_00,auStack200,2,param_8,\n                                *(undefined *)((longlong)(auStack288 + 5) + lVar14));\n        } while (puVar20 < puVar4);\n        goto LAB_00402180;\n      }\n    }\n  }\n  else {\n    if (flNewProtect == 0) {\n      uVar19 = *(uint *)(PTR_DAT_00405410 + 4);\n      if ((uVar19 | *(uint *)(PTR_DAT_00405410 + 8)) == 0) {\n        flNewProtect = *(int *)(PTR_DAT_00405410 + 0xc);\n        piVar22 = (int *)(PTR_DAT_00405410 + 0xc);\n        goto LAB_0040208d;\n      }\n      goto LAB_00402098;\n    }\n  }\n  if (PTR_DAT_00405400 <= piVar22) {\n    DAT_00408614 = 0;\n    return;\n  }\n  piVar1 = (int *)((longlong)piVar22 +\n                  ((ulonglong)(PTR_DAT_00405400 + (-1 - (longlong)piVar22)) & 0xfffffffffffffff8) +\n                  8);\n  dwSize = extraout_XMM0_Qa_02;\n  do {\n    uVar19 = piVar22[1];\n    flNewProtect = *piVar22;\n    piVar22 = piVar22 + 2;\n    auStack200[0] =\n         auStack200[0] & 0xffffffff00000000 |\n         (ulonglong)(uint)(flNewProtect + *(int *)(puVar5 + uVar19));\n    *(ulonglong *)((longlong)(auStack288 + 5) + lVar14) = 0x4022a7;\n    dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,puVar5 + uVar19,auStack200,4,param_8,\n                          *(undefined *)((longlong)(auStack288 + 5) + lVar14));\n  } while (piVar22 != piVar1);\nLAB_00402180:\n  if (0 < DAT_00408614) {\n    lVar21 = 0;\n    do {\n      piVar22 = (int *)(DAT_00408618 + lVar21);\n      flNewProtect = *piVar22;\n      if (flNewProtect != 0) {\n        dwSize = *(undefined8 *)(piVar22 + 4);\n        lpAddress = *(undefined8 *)(piVar22 + 2);\n        *(ulonglong *)((longlong)(auStack288 + 5) + lVar14) = 0x4021c0;\n        VirtualProtect(lpAddress,dwSize,flNewProtect,auStack200,\n                       *(undefined *)((longlong)(auStack288 + 5) + lVar14));\n      }\n      iVar15 = iVar15 + 1;\n      lVar21 = lVar21 + 0x28;\n    } while (iVar15 < DAT_00408614);\n  }\n  return;\n}\n\n\nvoid FUN_00401ff0(undefined8 param_1,undefined8 param_2,undefined8 param_3,undefined8 param_4,\n                 undefined8 param_5,undefined8 param_6,ulonglong param_7,longlong param_8)\n\n{\n  int *piVar1;\n  ulonglong uVar2;\n  byte bVar3;\n  ushort uVar4;\n  undefined8 lpAddress;\n  undefined *puVar5;\n  undefined *puVar6;\n  uint uVar7;\n  longlong lVar8;\n  ulonglong uVar9;\n  undefined4 uVar10;\n  longlong *plVar11;\n  int flNewProtect;\n  longlong *plVar12;\n  uint *puVar13;\n  longlong lVar14;\n  int *piVar15;\n  int iVar16;\n  undefined8 extraout_XMM0_Qa;\n  undefined8 dwSize;\n  undefined8 auStack216 [5];\n  undefined4 auStack176 [2];\n  ulonglong auStack168 [5];\n  undefined8 uStack128;\n  undefined auStack88 [8];\n  ulonglong local_50 [2];\n  \n  iVar16 = DAT_00408610;\n  if (DAT_00408610 != 0) {\n    return;\n  }\n  DAT_00408610 = 1;\n  uStack128 = 0x402037;\n  FUN_00402bd0();\n  uStack128 = 0x40204e;\n  lVar8 = FUN_00402df0();\n  puVar6 = PTR_IMAGE_DOS_HEADER_00405430;\n  puVar5 = PTR_DAT_00405400;\n  DAT_00408614 = 0;\n  lVar8 = -lVar8;\n  DAT_00408618 = auStack88 + lVar8;\n  if ((longlong)(PTR_DAT_00405400 + -(longlong)PTR_DAT_00405410) < 8) {\n    DAT_00408614 = 0;\n    return;\n  }\n  flNewProtect = *(int *)PTR_DAT_00405410;\n  piVar15 = (int *)PTR_DAT_00405410;\n  if ((longlong)(PTR_DAT_00405400 + -(longlong)PTR_DAT_00405410) < 0xc) {\nLAB_0040208d:\n    if (flNewProtect == 0) {\n      uVar7 = piVar15[1];\nLAB_00402098:\n      if (uVar7 == 0) {\n        uVar9 = (ulonglong)(uint)piVar15[2];\n        dwSize = extraout_XMM0_Qa;\n        if (piVar15[2] != 1) {\nLAB_004022c8:\n          uVar10 = 0x405300;\n          *(ulonglong *)((longlong)(auStack168 + 5) + lVar8) = 0x4022d4;\n          FUN_00401d70(dwSize,param_2,param_3,param_4,\n                       \"  Unknown pseudo relocation protocol version %d.\\n\",uVar9,param_7,param_8,\n                       *(undefined *)((longlong)(auStack168 + 5) + lVar8));\n          if (DAT_00408620 != (code *)0x0) {\n            uVar2 = *(ulonglong *)((longlong)local_50 + lVar8);\n            *(undefined4 *)((longlong)auStack176 + lVar8) = uVar10;\n            *(ulonglong *)((longlong)auStack168 + lVar8) = uVar9;\n            *(undefined8 *)((longlong)auStack168 + lVar8 + 8) = param_3;\n            *(undefined8 *)((longlong)auStack168 + lVar8 + 0x10) = param_4;\n            *(ulonglong *)((longlong)auStack168 + lVar8 + 0x18) = uVar2;\n            *(undefined8 *)((longlong)auStack216 + lVar8) = 0x40231b;\n            (*DAT_00408620)((undefined4 *)((longlong)auStack176 + lVar8));\n          }\n          return;\n        }\n        puVar13 = (uint *)(piVar15 + 3);\n        if (PTR_DAT_00405400 <= puVar13) {\n          DAT_00408614 = 0;\n          return;\n        }\n        do {\n          while( true ) {\n            bVar3 = *(byte *)(puVar13 + 2);\n            param_7 = (ulonglong)bVar3;\n            plVar12 = (longlong *)(puVar6 + *puVar13);\n            plVar11 = (longlong *)(puVar6 + puVar13[1]);\n            param_8 = *plVar12;\n            if (bVar3 != 0x20) break;\n            uVar7 = *(uint *)plVar11;\n            uVar9 = (ulonglong)uVar7 | 0xffffffff00000000;\n            if (-1 < (int)uVar7) {\n              uVar9 = (ulonglong)uVar7;\n            }\n            local_50[0] = (uVar9 - (longlong)plVar12) + param_8;\n            *(ulonglong *)((longlong)(auStack168 + 5) + lVar8) = 0x40225a;\n            dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,plVar11,local_50,4,param_8,\n                                  *(undefined *)((longlong)(auStack168 + 5) + lVar8));\nLAB_00402100:\n            puVar13 = puVar13 + 3;\n            if (puVar5 <= puVar13) goto LAB_00402180;\n          }\n          if (0x20 < bVar3) {\n            if (bVar3 == 0x40) {\n              local_50[0] = (*plVar11 - (longlong)plVar12) + param_8;\n              *(ulonglong *)((longlong)(auStack168 + 5) + lVar8) = 0x402228;\n              dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,plVar11,local_50,8,param_8,\n                                    *(undefined *)((longlong)(auStack168 + 5) + lVar8));\n              goto LAB_00402100;\n            }\nLAB_004022b1:\n            uVar9 = (ulonglong)bVar3;\n            local_50[0] = 0;\n            *(ulonglong *)((longlong)(auStack168 + 5) + lVar8) = 0x4022c8;\n            dwSize = FUN_00401d70(dwSize,param_2,param_3,param_4,\n                                  \"  Unknown pseudo relocation bit size %d.\\n\",uVar9,param_7,param_8\n                                  ,*(undefined *)((longlong)(auStack168 + 5) + lVar8));\n            goto LAB_004022c8;\n          }\n          if (bVar3 == 8) {\n            bVar3 = *(byte *)plVar11;\n            uVar9 = (ulonglong)bVar3;\n            if ((char)bVar3 < '\\0') {\n              uVar9 = (ulonglong)bVar3 | 0xffffffffffffff00;\n            }\n            local_50[0] = (uVar9 - (longlong)plVar12) + param_8;\n            *(ulonglong *)((longlong)(auStack168 + 5) + lVar8) = 0x402100;\n            dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,plVar11,local_50,1,param_8,\n                                  *(undefined *)((longlong)(auStack168 + 5) + lVar8));\n            goto LAB_00402100;\n          }\n          if (bVar3 != 0x10) goto LAB_004022b1;\n          uVar4 = *(ushort *)plVar11;\n          uVar9 = (ulonglong)uVar4;\n          if ((short)uVar4 < 0) {\n            uVar9 = (ulonglong)uVar4 | 0xffffffffffff0000;\n          }\n          puVar13 = puVar13 + 3;\n          local_50[0] = (uVar9 - (longlong)plVar12) + param_8;\n          *(ulonglong *)((longlong)(auStack168 + 5) + lVar8) = 0x402171;\n          dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,plVar11,local_50,2,param_8,\n                                *(undefined *)((longlong)(auStack168 + 5) + lVar8));\n        } while (puVar13 < puVar5);\n        goto LAB_00402180;\n      }\n    }\n  }\n  else {\n    if (flNewProtect == 0) {\n      uVar7 = *(uint *)(PTR_DAT_00405410 + 4);\n      if ((uVar7 | *(uint *)(PTR_DAT_00405410 + 8)) == 0) {\n        flNewProtect = *(int *)(PTR_DAT_00405410 + 0xc);\n        piVar15 = (int *)(PTR_DAT_00405410 + 0xc);\n        goto LAB_0040208d;\n      }\n      goto LAB_00402098;\n    }\n  }\n  if (PTR_DAT_00405400 <= piVar15) {\n    DAT_00408614 = 0;\n    return;\n  }\n  piVar1 = (int *)((longlong)piVar15 +\n                  ((ulonglong)(PTR_DAT_00405400 + (-1 - (longlong)piVar15)) & 0xfffffffffffffff8) +\n                  8);\n  dwSize = extraout_XMM0_Qa;\n  do {\n    uVar7 = piVar15[1];\n    flNewProtect = *piVar15;\n    piVar15 = piVar15 + 2;\n    local_50[0] = local_50[0] & 0xffffffff00000000 |\n                  (ulonglong)(uint)(flNewProtect + *(int *)(puVar6 + uVar7));\n    *(ulonglong *)((longlong)(auStack168 + 5) + lVar8) = 0x4022a7;\n    dwSize = FUN_00401de0(dwSize,param_2,param_3,param_4,puVar6 + uVar7,local_50,4,param_8,\n                          *(undefined *)((longlong)(auStack168 + 5) + lVar8));\n  } while (piVar15 != piVar1);\nLAB_00402180:\n  if (0 < DAT_00408614) {\n    lVar14 = 0;\n    do {\n      piVar15 = (int *)(DAT_00408618 + lVar14);\n      flNewProtect = *piVar15;\n      if (flNewProtect != 0) {\n        dwSize = *(undefined8 *)(piVar15 + 4);\n        lpAddress = *(undefined8 *)(piVar15 + 2);\n        *(ulonglong *)((longlong)(auStack168 + 5) + lVar8) = 0x4021c0;\n        VirtualProtect(lpAddress,dwSize,flNewProtect,local_50,\n                       *(undefined *)((longlong)(auStack168 + 5) + lVar8));\n      }\n      iVar16 = iVar16 + 1;\n      lVar14 = lVar14 + 0x28;\n    } while (iVar16 < DAT_00408614);\n  }\n  return;\n}\n\n\nvoid FUN_00402330(undefined8 param_1)\n\n{\n  DAT_00408620 = param_1;\n                    /* WARNING: Could not recover jumptable at 0x00402ed8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  __setusermatherr();\n  return;\n}\n\n\nulonglong FUN_00402340(uint *param_1)\n\n{\n  uint uVar1;\n  code *extraout_RAX;\n  code *extraout_RAX_00;\n  code *extraout_RAX_01;\n  code *pcVar2;\n  code *extraout_RAX_02;\n  \n  uVar1 = *param_1;\n  if (0xc0000096 < uVar1) {\n    return 1;\n  }\n  if (0xc000008b < uVar1) {\n    switch(uVar1) {\n    case 0xc000008d:\n    case 0xc000008e:\n    case 0xc000008f:\n    case 0xc0000090:\n    case 0xc0000091:\n    case 0xc0000093:\n      signal(8);\n      pcVar2 = extraout_RAX;\n      if (extraout_RAX != (code *)0x1) goto LAB_0040242d;\n      signal(8);\n      FUN_00401d60();\n    default:\n      return 0;\n    case 0xc0000094:\n      signal(8);\n      pcVar2 = extraout_RAX_01;\n      if (extraout_RAX_01 == (code *)0x1) {\n        signal(8);\n        return 0;\n      }\nLAB_0040242d:\n      if (pcVar2 != (code *)0x0) {\n        (*pcVar2)(8);\n        return 0;\n      }\n      return 1;\n    case 0xc0000096:\n      goto switchD_00402370_caseD_c0000096;\n    }\n  }\n  if (uVar1 == 0xc0000005) {\n    signal(0xb);\n    if (extraout_RAX_02 == (code *)0x1) {\n      signal(0xb);\n      return 0;\n    }\n    if (extraout_RAX_02 != (code *)0x0) {\n      (*extraout_RAX_02)(0xb);\n      return 0;\n    }\n  }\n  else {\n    if (uVar1 < 0xc0000006) {\n      return (ulonglong)(uVar1 != 0x80000002);\n    }\n    if (uVar1 == 0xc0000008) {\n      return 0;\n    }\n    if (uVar1 != 0xc000001d) {\n      return 1;\n    }\nswitchD_00402370_caseD_c0000096:\n    signal(4);\n    if (extraout_RAX_00 == (code *)0x1) {\n      signal(4);\n      return 0;\n    }\n    if (extraout_RAX_00 != (code *)0x0) {\n      (*extraout_RAX_00)(4);\n      return 0;\n    }\n  }\n  return 4;\n}\n\n\nulonglong FUN_00402500(void)\n\n{\n  int iVar1;\n  IMAGE_DOS_HEADER *BaseAddress;\n  char *pcVar2;\n  ulonglong uVar3;\n  longlong lVar4;\n  DWORD EntryCount;\n  undefined8 *puVar5;\n  undefined8 *puVar6;\n  longlong lVar7;\n  \n  BaseAddress = FUN_00402c70();\n  uVar3 = (ulonglong)DAT_00408648;\n  if ((DAT_00408648 == 0) && (BaseAddress != (IMAGE_DOS_HEADER *)0x0)) {\n    DAT_00408648 = 1;\n    pcVar2 = FUN_00402aa0(\".pdata\");\n    if (pcVar2 == (char *)0x0) {\n      lVar4 = 0x30;\n      lVar7 = 0;\n      puVar5 = &DAT_00408760;\n      while (lVar4 != 0) {\n        lVar4 = lVar4 + -1;\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n      }\n      lVar4 = 0x20;\n      puVar5 = &DAT_00408660;\n      while (lVar4 != 0) {\n        lVar4 = lVar4 + -1;\n        *puVar5 = 0;\n        puVar5 = puVar5 + 1;\n      }\n      puVar5 = &DAT_00408760;\n      puVar6 = &DAT_00408660;\n      do {\n        pcVar2 = FUN_00402c00(lVar7);\n        if (pcVar2 == (char *)0x0) {\n          if (lVar7 == 0) goto LAB_0040253c;\n          EntryCount = (DWORD)lVar7;\n          goto LAB_004025e5;\n        }\n        *(undefined *)puVar6 = 9;\n        lVar7 = lVar7 + 1;\n        *(int *)((longlong)puVar6 + 4) = 0x402340 - (int)BaseAddress;\n        iVar1 = *(int *)(pcVar2 + 0xc);\n        *(int *)puVar5 = iVar1;\n        *(int *)((longlong)puVar5 + 4) = iVar1 + *(int *)(pcVar2 + 8);\n        *(int *)(puVar5 + 1) = (int)puVar6 - (int)BaseAddress;\n        puVar5 = (undefined8 *)((longlong)puVar5 + 0xc);\n        puVar6 = puVar6 + 1;\n      } while (lVar7 != 0x20);\n      EntryCount = 0x20;\nLAB_004025e5:\n      RtlAddFunctionTable((PRUNTIME_FUNCTION)&DAT_00408760,EntryCount,(DWORD64)BaseAddress);\n    }\nLAB_0040253c:\n    uVar3 = 1;\n  }\n  return uVar3;\n}\n\n\nvoid FUN_004027b0(void)\n\n{\n  DWORD *pDVar1;\n  DWORD DVar2;\n  LPVOID pvVar3;\n  \n  EnterCriticalSection((LPCRITICAL_SECTION)&DAT_00408900);\n  pDVar1 = DAT_004088e0;\n  while (pDVar1 != (DWORD *)0x0) {\n    pvVar3 = TlsGetValue(*pDVar1);\n    DVar2 = GetLastError();\n    if ((DVar2 == 0) && (pvVar3 != (LPVOID)0x0)) {\n      (**(code **)(pDVar1 + 2))();\n    }\n    pDVar1 = *(DWORD **)(pDVar1 + 4);\n  }\n                    /* WARNING: Could not recover jumptable at 0x00402814. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_00408900);\n  return;\n}\n\n\nundefined8 FUN_00402930(undefined8 param_1,uint param_2)\n\n{\n  void *pvVar1;\n  void *_Memory;\n  \n  if (param_2 == 2) {\n    FUN_00401d60();\n    return 1;\n  }\n  if (param_2 < 3) {\n    if (param_2 == 0) {\n      if (DAT_004088e8 != 0) {\n        FUN_004027b0();\n      }\n      _Memory = DAT_004088e0;\n      if (DAT_004088e8 == 1) {\n        while (_Memory != (void *)0x0) {\n          pvVar1 = *(void **)((longlong)_Memory + 0x10);\n          free(_Memory);\n          _Memory = pvVar1;\n        }\n        DAT_004088e0 = (void *)0x0;\n        DAT_004088e8 = 0;\n        DeleteCriticalSection((LPCRITICAL_SECTION)&DAT_00408900);\n      }\n    }\n    else {\n      if (DAT_004088e8 == 0) {\n        InitializeCriticalSection((LPCRITICAL_SECTION)&DAT_00408900);\n      }\n      DAT_004088e8 = 1;\n    }\n  }\n  else {\n    if ((param_2 == 3) && (DAT_004088e8 != 0)) {\n      FUN_004027b0();\n    }\n  }\n  return 1;\n}\n\n\nulonglong FUN_00402a10(longlong param_1)\n\n{\n  int *piVar1;\n  ulonglong uVar2;\n  \n  piVar1 = (int *)(*(int *)(param_1 + 0x3c) + param_1);\n  uVar2 = 0;\n  if (*piVar1 == 0x4550) {\n    uVar2 = (ulonglong)(*(short *)(piVar1 + 6) == 0x20b);\n  }\n  return uVar2;\n}\n\n\nchar * FUN_00402aa0(char *param_1)\n\n{\n  char *pcVar1;\n  int iVar2;\n  size_t sVar3;\n  ulonglong uVar4;\n  undefined *puVar5;\n  char *_Str1;\n  \n  sVar3 = strlen(param_1);\n  if (8 < sVar3) {\n    return (char *)0x0;\n  }\n  if ((*(short *)PTR_IMAGE_DOS_HEADER_00405430 == 0x5a4d) &&\n     (puVar5 = PTR_IMAGE_DOS_HEADER_00405430,\n     uVar4 = FUN_00402a10((longlong)PTR_IMAGE_DOS_HEADER_00405430), (int)uVar4 != 0)) {\n    puVar5 = puVar5 + *(int *)(puVar5 + 0x3c);\n    _Str1 = puVar5 + (ulonglong)*(ushort *)(puVar5 + 0x14) + 0x18;\n    if (*(ushort *)(puVar5 + 6) == 0) {\n      return (char *)0x0;\n    }\n    pcVar1 = _Str1 + (ulonglong)((uint)*(ushort *)(puVar5 + 6) - 1) * 0x28 + 0x28;\n    do {\n      iVar2 = strncmp(_Str1,param_1,8);\n      if (iVar2 == 0) {\n        return _Str1;\n      }\n      _Str1 = _Str1 + 0x28;\n    } while (_Str1 != pcVar1);\n    return (char *)0x0;\n  }\n  return (char *)0x0;\n}\n\n\nchar * FUN_00402b40(longlong param_1)\n\n{\n  char *pcVar1;\n  ulonglong uVar2;\n  char *pcVar3;\n  undefined *puVar4;\n  undefined *puVar5;\n  \n  pcVar3 = (char *)0x0;\n  if ((*(short *)PTR_IMAGE_DOS_HEADER_00405430 == 0x5a4d) &&\n     (puVar4 = PTR_IMAGE_DOS_HEADER_00405430,\n     uVar2 = FUN_00402a10((longlong)PTR_IMAGE_DOS_HEADER_00405430), (int)uVar2 != 0)) {\n    puVar5 = puVar4 + *(int *)(puVar4 + 0x3c);\n    pcVar3 = puVar5 + (ulonglong)*(ushort *)(puVar5 + 0x14) + 0x18;\n    if (*(ushort *)(puVar5 + 6) != 0) {\n      pcVar1 = pcVar3 + (ulonglong)((uint)*(ushort *)(puVar5 + 6) - 1) * 0x28 + 0x28;\n      do {\n        if (((ulonglong)*(uint *)(pcVar3 + 0xc) <= (ulonglong)(param_1 - (longlong)puVar4)) &&\n           ((ulonglong)(param_1 - (longlong)puVar4) <\n            (ulonglong)(*(uint *)(pcVar3 + 0xc) + *(int *)(pcVar3 + 8)))) {\n          return pcVar3;\n        }\n        pcVar3 = pcVar3 + 0x28;\n      } while (pcVar3 != pcVar1);\n    }\n    pcVar3 = (char *)0x0;\n  }\n  return pcVar3;\n}\n\n\nulonglong FUN_00402bd0(void)\n\n{\n  ulonglong uVar1;\n  undefined *puVar2;\n  \n  uVar1 = 0;\n  if (*(short *)PTR_IMAGE_DOS_HEADER_00405430 == 0x5a4d) {\n    puVar2 = PTR_IMAGE_DOS_HEADER_00405430;\n    uVar1 = FUN_00402a10((longlong)PTR_IMAGE_DOS_HEADER_00405430);\n    if ((int)uVar1 != 0) {\n      uVar1 = (ulonglong)*(ushort *)(puVar2 + (longlong)*(int *)(puVar2 + 0x3c) + 6);\n    }\n  }\n  return uVar1;\n}\n\n\nchar * FUN_00402c00(longlong param_1)\n\n{\n  char *pcVar1;\n  ulonglong uVar2;\n  undefined *puVar3;\n  char *pcVar4;\n  \n  pcVar4 = (char *)0x0;\n  if ((*(short *)PTR_IMAGE_DOS_HEADER_00405430 == 0x5a4d) &&\n     (puVar3 = PTR_IMAGE_DOS_HEADER_00405430,\n     uVar2 = FUN_00402a10((longlong)PTR_IMAGE_DOS_HEADER_00405430), (int)uVar2 != 0)) {\n    puVar3 = puVar3 + *(int *)(puVar3 + 0x3c);\n    pcVar4 = puVar3 + (ulonglong)*(ushort *)(puVar3 + 0x14) + 0x18;\n    if (*(ushort *)(puVar3 + 6) != 0) {\n      pcVar1 = pcVar4 + (ulonglong)((uint)*(ushort *)(puVar3 + 6) - 1) * 0x28 + 0x28;\n      do {\n        if ((pcVar4[0x27] & 0x20U) != 0) {\n          if (param_1 == 0) {\n            return pcVar4;\n          }\n          param_1 = param_1 + -1;\n        }\n        pcVar4 = pcVar4 + 0x28;\n      } while (pcVar4 != pcVar1);\n    }\n    pcVar4 = (char *)0x0;\n  }\n  return pcVar4;\n}\n\n\nIMAGE_DOS_HEADER * FUN_00402c70(void)\n\n{\n  ulonglong uVar1;\n  IMAGE_DOS_HEADER *pIVar2;\n  IMAGE_DOS_HEADER *pIVar3;\n  \n  pIVar3 = (IMAGE_DOS_HEADER *)0x0;\n  if (*(short *)PTR_IMAGE_DOS_HEADER_00405430 == 0x5a4d) {\n    pIVar2 = (IMAGE_DOS_HEADER *)PTR_IMAGE_DOS_HEADER_00405430;\n    uVar1 = FUN_00402a10((longlong)PTR_IMAGE_DOS_HEADER_00405430);\n    if ((int)uVar1 != 0) {\n      pIVar3 = pIVar2;\n    }\n  }\n  return pIVar3;\n}\n\n\nulonglong FUN_00402df0(void)\n\n{\n  ulonglong in_RAX;\n  ulonglong uVar1;\n  undefined8 *puVar2;\n  undefined8 local_res8 [4];\n  ulonglong uStack16;\n  \n  puVar2 = local_res8;\n  uVar1 = in_RAX;\n  if (0xfff < in_RAX) {\n    do {\n      puVar2 = puVar2 + -0x200;\n      *puVar2 = *puVar2;\n      uVar1 = uVar1 - 0x1000;\n    } while (0x1000 < uVar1);\n  }\n  uStack16 = in_RAX;\n  *(undefined8 *)((longlong)puVar2 - uVar1) = *(undefined8 *)((longlong)puVar2 - uVar1);\n  return uStack16;\n}\n\n\nint vfprintf(FILE *_File,char *_Format,va_list _ArgList)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e30. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = vfprintf(_File,_Format,_ArgList);\n  return iVar1;\n}\n\n\nint strncmp(char *_Str1,char *_Str2,size_t _MaxCount)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e38. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = strncmp(_Str1,_Str2,_MaxCount);\n  return iVar1;\n}\n\n\nsize_t strlen(char *_Str)\n\n{\n  size_t sVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e40. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  sVar1 = strlen(_Str);\n  return sVar1;\n}\n\n\nint sprintf(char *_Dest,char *_Format,...)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e48. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = sprintf(_Dest,_Format);\n  return iVar1;\n}\n\n\n/* WARNING: Unknown calling convention yet parameter storage is locked */\n\nvoid signal(int param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00402e50. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  signal(param_1);\n  return;\n}\n\n\nint puts(char *_Str)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e58. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = puts(_Str);\n  return iVar1;\n}\n\n\nint printf(char *_Format,...)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = printf(_Format);\n  return iVar1;\n}\n\n\nvoid * memcpy(void *_Dst,void *_Src,size_t _Size)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e68. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = memcpy(_Dst,_Src,_Size);\n  return pvVar1;\n}\n\n\nvoid * malloc(size_t _Size)\n\n{\n  void *pvVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e70. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pvVar1 = malloc(_Size);\n  return pvVar1;\n}\n\n\nchar * getenv(char *_VarName)\n\n{\n  char *pcVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e78. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pcVar1 = getenv(_VarName);\n  return pcVar1;\n}\n\n\nsize_t fwrite(void *_Str,size_t _Size,size_t _Count,FILE *_File)\n\n{\n  size_t sVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e80. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  sVar1 = fwrite(_Str,_Size,_Count,_File);\n  return sVar1;\n}\n\n\nvoid free(void *_Memory)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00402e88. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  free(_Memory);\n  return;\n}\n\n\nint fprintf(FILE *_File,char *_Format,...)\n\n{\n  int iVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e90. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  iVar1 = fprintf(_File,_Format);\n  return iVar1;\n}\n\n\nFILE * fopen(char *_Filename,char *_Mode)\n\n{\n  FILE *pFVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402e98. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pFVar1 = fopen(_Filename,_Mode);\n  return pFVar1;\n}\n\n\n/* WARNING: Exceeded maximum restarts with more pending */\n\nvoid exit(int _Code)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00402ea0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  exit();\n  return;\n}\n\n\nvoid abort(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00402eb0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  abort();\n  return;\n}\n\n\n_onexit_t _onexit(_onexit_t _Func)\n\n{\n  _onexit_t p_Var1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402eb8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  p_Var1 = _onexit(_Func);\n  return p_Var1;\n}\n\n\nvoid _initterm(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00402ec0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  _initterm();\n  return;\n}\n\n\nvoid _cexit(void)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00402ec8. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  _cexit();\n  return;\n}\n\n\nvoid _amsg_exit(int param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00402ed0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  _amsg_exit(param_1);\n  return;\n}\n\n\nvoid __set_app_type(int param_1)\n\n{\n                    /* WARNING: Could not recover jumptable at 0x00402ee0. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  __set_app_type(param_1);\n  return;\n}\n\n\nFILE * FUN_00402f00(uint param_1)\n\n{\n  FILE *pFVar1;\n  \n  pFVar1 = __iob_func();\n  return pFVar1 + param_1;\n}\n\n\nundefined8 FUN_00402f30(undefined8 param_1)\n\n{\n  undefined8 uVar1;\n  \n  uVar1 = DAT_00408950;\n  DAT_00408950 = param_1;\n  return uVar1;\n}\n\n\nundefined * FUN_00402f40(void)\n\n{\n  return *(undefined **)PTR_PTR__acmdln_00405450;\n}\n\n\nundefined * FUN_00402f50(void)\n\n{\n  return *(undefined **)PTR_PTR__fmode_00405460;\n}\n\n\nFILE * __iob_func(void)\n\n{\n  FILE *pFVar1;\n  \n                    /* WARNING: Could not recover jumptable at 0x00402f60. Too many branches */\n                    /* WARNING: Treating indirect jump as call */\n  pFVar1 = __iob_func();\n  return pFVar1;\n}\n\n"}}